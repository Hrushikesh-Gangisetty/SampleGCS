package com.example.aerogcsclone.export

import android.content.Context
import android.content.Intent
import androidx.core.content.FileProvider
import com.example.aerogcsclone.database.tlog.*
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.*

/**
 * Service for exporting flight logs in various formats
 */
class FlightLogExporter(private val context: Context) {

    private val gson: Gson = GsonBuilder()
        .setPrettyPrinting()
        .create()

    /**
     * Export flight data as JSON
     */
    suspend fun exportFlightAsJson(
        flight: FlightEntity,
        telemetryData: List<TelemetryEntity>,
        events: List<EventEntity>,
        mapData: List<MapDataEntity>
    ): File = withContext(Dispatchers.IO) {
        val flightData = FlightExportData(
            flight = flight,
            telemetry = telemetryData,
            events = events,
            mapData = mapData,
            exportedAt = System.currentTimeMillis(),
            version = "1.0"
        )

        val fileName = "flight_${flight.id}_${formatDateForFile(flight.startTime)}.json"
        val file = File(context.getExternalFilesDir(null), fileName)

        FileWriter(file).use { writer ->
            gson.toJson(flightData, writer)
        }

        file
    }

    /**
     * Export flight data as CSV
     */
    suspend fun exportFlightAsCsv(
        flight: FlightEntity,
        telemetryData: List<TelemetryEntity>
    ): File = withContext(Dispatchers.IO) {
        val fileName = "flight_${flight.id}_${formatDateForFile(flight.startTime)}.csv"
        val file = File(context.getExternalFilesDir(null), fileName)

        FileWriter(file).use { writer ->
            // CSV Header
            writer.appendLine("timestamp,formatted_time,voltage,current,battery_percent,sat_count,hdop,altitude,speed,latitude,longitude,heading")

            // CSV Data with formatted timestamps
            telemetryData.forEach { telemetry ->
                writer.appendLine(
                    "${telemetry.timestamp}," +
                    "\"${formatDateTime(telemetry.timestamp)}\"," +
                    "${telemetry.voltage ?: ""}," +
                    "${telemetry.current ?: ""}," +
                    "${telemetry.batteryPercent ?: ""}," +
                    "${telemetry.satCount ?: ""}," +
                    "${telemetry.hdop ?: ""}," +
                    "${telemetry.altitude ?: ""}," +
                    "${telemetry.speed ?: ""}," +
                    "${telemetry.latitude ?: ""}," +
                    "${telemetry.longitude ?: ""}," +
                    "${telemetry.heading ?: ""}"
                )
            }
        }

        file
    }

    /**
     * Export flight data in .tlog-like format (text-based MAVLink-style)
     */
    suspend fun exportFlightAsTlog(
        flight: FlightEntity,
        telemetryData: List<TelemetryEntity>,
        events: List<EventEntity>,
        mapData: List<MapDataEntity>
    ): File = withContext(Dispatchers.IO) {
        val fileName = "flight_${flight.id}_${formatDateForFile(flight.startTime)}.tlog"
        val file = File(context.getExternalFilesDir(null), fileName)

        FileWriter(file).use { writer ->
            // Header information
            writer.appendLine("# Flight Log Export")
            writer.appendLine("# Generated by Pavaman Aviation GCS")
            writer.appendLine("# Flight ID: ${flight.id}")
            writer.appendLine("# Start Time: ${formatDateTime(flight.startTime)}")
            writer.appendLine("# Duration: ${flight.flightDuration?.let { formatDuration(it) } ?: "N/A"}")
            writer.appendLine("# Export Time: ${formatDateTime(System.currentTimeMillis())}")
            writer.appendLine("")

            // Flight events and telemetry in chronological order
            val allData = mutableListOf<TlogEntry>()

            // Add telemetry entries
            telemetryData.forEach { telemetry ->
                allData.add(TlogEntry(
                    timestamp = telemetry.timestamp,
                    type = "TELEMETRY",
                    data = "BATTERY: ${telemetry.voltage}V ${telemetry.batteryPercent}% | " +
                           "GPS: ${telemetry.satCount} sats ${telemetry.hdop} hdop | " +
                           "POS: ${telemetry.latitude},${telemetry.longitude} ALT:${telemetry.altitude}m | " +
                           "SPD: ${telemetry.speed}m/s HDG:${telemetry.heading}Â°"
                ))
            }

            // Add event entries
            events.forEach { event ->
                allData.add(TlogEntry(
                    timestamp = event.timestamp,
                    type = "EVENT",
                    data = "${event.eventType.name} [${event.severity.name}]: ${event.message}"
                ))
            }

            // Sort by timestamp and write
            allData.sortBy { it.timestamp }
            allData.forEach { entry ->
                val timeStr = formatDateTime(entry.timestamp)
                writer.appendLine("$timeStr [${entry.type}] ${entry.data}")
            }
        }

        file
    }

    /**
     * Export all flights summary as CSV
     */
    suspend fun exportAllFlightsAsCsv(flights: List<FlightEntity>): File = withContext(Dispatchers.IO) {
        val fileName = "all_flights_summary_${formatDateForFile(System.currentTimeMillis())}.csv"
        val file = File(context.getExternalFilesDir(null), fileName)

        FileWriter(file).use { writer ->
            // CSV Header
            writer.appendLine("flight_id,start_time,end_time,duration_minutes,area_hectares,max_altitude,max_speed,total_distance,completed")

            // CSV Data
            flights.forEach { flight ->
                writer.appendLine(
                    "${flight.id}," +
                    "${formatDateTime(flight.startTime)}," +
                    "${flight.endTime?.let { formatDateTime(it) } ?: ""}," +
                    "${flight.flightDuration?.let { it / 60000 } ?: ""}," +
                    "${flight.area ?: ""}," +
                    "${flight.maxAltitude ?: ""}," +
                    "${flight.maxSpeed ?: ""}," +
                    "${flight.totalDistance ?: ""}," +
                    "${flight.isCompleted}"
                )
            }
        }

        file
    }

    /**
     * Share exported file using Android's share intent
     */
    suspend fun shareFile(file: File, title: String = "Share Flight Log") {
        withContext(Dispatchers.Main) {
            try {
                val uri = FileProvider.getUriForFile(
                    context,
                    "${context.packageName}.fileprovider",
                    file
                )

                val intent = Intent(Intent.ACTION_SEND).apply {
                    type = when (file.extension.lowercase()) {
                        "json" -> "application/json"
                        "csv" -> "text/csv"
                        "tlog" -> "text/plain"
                        else -> "*/*"
                    }
                    putExtra(Intent.EXTRA_STREAM, uri)
                    putExtra(Intent.EXTRA_SUBJECT, title)
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }

                val shareIntent = Intent.createChooser(intent, title)
                shareIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(shareIntent)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    private fun formatDateForFile(timestamp: Long): String {
        return SimpleDateFormat("yyyy-MM-dd_HH-mm-ss", Locale.getDefault()).format(Date(timestamp))
    }

    private fun formatDateTime(timestamp: Long): String {
        return SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault()).format(Date(timestamp))
    }

    private fun formatDuration(durationMs: Long): String {
        val hours = durationMs / (1000 * 60 * 60)
        val minutes = (durationMs % (1000 * 60 * 60)) / (1000 * 60)
        val seconds = (durationMs % (1000 * 60)) / 1000

        return when {
            hours > 0 -> String.format(Locale.getDefault(), "%02d:%02d:%02d", hours, minutes, seconds)
            minutes > 0 -> String.format(Locale.getDefault(), "%02d:%02d", minutes, seconds)
            else -> String.format(Locale.getDefault(), "00:%02d", seconds)
        }
    }
}

/**
 * Data classes for export
 */
data class FlightExportData(
    val flight: FlightEntity,
    val telemetry: List<TelemetryEntity>,
    val events: List<EventEntity>,
    val mapData: List<MapDataEntity>,
    val exportedAt: Long,
    val version: String
)

data class TlogEntry(
    val timestamp: Long,
    val type: String,
    val data: String
)
